//#pragma comment(linker, "/SECTION:.text,ERW /MERGE:.rdata=.text /MERGE:.data=.text")
//#pragma comment(linker, "/SECTION:.Xmoe,ERW /MERGE:.text=.Xmoe")


//#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\"")

/*
C0GGGCfttfttt;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;i;iiiiiiiiiiiiiiii
.....,LfffLGCfttttttttttttttttttttLfLCLi,.......1;t.......,,,,,,,....,,,,,,,............
.....,ffttf,..:f0000CfttttffLCCLft,1fLL ;Lf:tLt1LfL;t;;;;;;;iiiiii11111111111111111111111
......tfttf,.......:11itL1i1tLLLLLLLLLLLLLLLLtf:,tLLLLLtfi;iiiiiiiii11ii11111iii1i1111111
......1ittf,....fttLLt1tt1LftLLLLLLLLLLLLf::LLt1Lt1LL:LLLLLf11................
......ii;tf,..LtCCttLLLLLLftLttLLLLLLLLLLLLLLLLf1ft1tt1t1111tttti,...............
......ii;;f,.fCftLLLLLLLLLLL1fLtLLLLLLLCCfffffLCCtfftfttt1tt1tttt1t1i...............
......ii;;i,.ffLLLLLLLLLLLLLLttCfCCffffCLLLf1t111t1tftLLLLLLLLLLLLttCff,.................
......ii;;i,.CCCCCCCCCCCCCfi;it1f1LCCCftttLLLLLLLLLttftLLLLLLLLLLLL1tLftfL...............
......ii;;i,.LCCCCCf:;;LGCCCCLLt1ttffCCCCCCLLLLLLLLLtfttLLLLLLLLLLLL11LftfLLL............
......ii;;i,.::t.;;LLi;;;;;;;;;;;;;;;i;;;;;;LCCLLLLLLtLttLLLLLCCCCCCCtfCLfCCCLL..........
......ii;;i:,.,;:i::;;;;;::..........,..,;;;;;;iCCCLLftLtLCCCCCCCCCCCCttCffCCCCC.........
......ii;i,.:...:.........................i...::;;;1CCffLtLCCfffffftttf11LttLffff........
......i1..,...1....  ...... ........,......,.......,;;;;;iffftLCCCCCLfft1tt1tttfffL......
.....;.,.... ,..... ;...... ........i......:.............:;i;;iLfttfCCCCftCffCCCCCCC.....
;;.:.ii............,....... ........:.......;..............i.;,:;;tGCCCCCfLCtLCCCCCCf....
ft :L1,... ................ ........:.......:........ .i..  ;.;:tf,:;GCCCffCtfCCCCCCC....
.t,CCi....;.......,........ ........;........;..  .... .,...fff,.....;;CCCtCCtCCCCCCCi...
tLG;i.,.., .......1........ . .....:;........i:.............;Lffftii1.ii;CtfGffCCCCCCL...
tCG; :.. ,   .....1    ....  ......i:;.......;:..........i...ti. .....:;t;1fCffCCCCCC;...
tCG,.i............i.. ............,i.::......,.i:......;,,...,i. ....i t:t;;;ffCCCCC:....
tCG.;:..i.........; .......:......:i .i......, ,1,..,:.:,.;...;.:....1.ti.1f;;;,......,::
tC,.;...:....:....;........t......;;. :1.....,..:i......i.i...i.;....;,;1..;;;;tft1iii;;;
tC.,t...:....t,...:1.....:.,:.....;:. .:....., ,,;;.....;,:...;.,....;:.:..,t::Lftt;;f;;t
tC.;t...;....t.....:,....::.:.....1:,  ,i....:   ,;;....;:,;.,:.,...11;....:t.,Ltttt1,;f,
t1.it...;....,....,i::...::.;i....i:,  .,;..,;  .,.,:...:;,:.,,.:...;1;,.......ftt1;i:1,i
t:.1;...;.....:....;:i:,.;:..:;...:;,.  ,:..,.   .  :C1..,,,....;...i1t:.......ftt1,:1i.1
f,.ti...1;....;....,:.;::.:. .,....,,.  ,,:,,.      .GL..,,,:...i,.1tft;.......ttt11i,,L.
t,.;;...;;,...:;...:;. :::,,. .....,.. ..,,,,        GG.......:,,..;;fti,......1tt1,:1;,1
f:;;t...;i;....1,...;:...,:GG      .... .,,..       .iG1     .,i..i;,;;t:......itt1;i,t,i
ffLft1,.:;i;...,;,..;::.....G .          ..,         .GG     .,.i.;;,t;t;......itt1t1111t
fCG. t:..i;;;,..1;i..:.,.  .GG           . .       ...G0..  .,;,:;i;1t;;;......1ftt  f. t
fCGfft::.:i;i;;..i::.:...   .G:          ..      ...........::,t;i;fiLi;;......1fttff tt,
fCGLLtt;,,1;11;;..i::;:.    .;G......          ..............;;;1i:iiL;;;......tfftLfffff
fC0  tt;;.tt;;i;;;,;;;::.. ...GG..........     ............,,11;;;.;if;;;:..:..1LLf;:,,,.
fC0  tti;;it11t;i;;1;i:;f.......,........       ..........,.:;;if;.;it;;;;..i..,
fC0  t;;t;iL;1t;;i;;1;;;1i............ .          .........it;i;i:.;i1;;;;..i....
LG0  f;;;1;t;11;;;fi;i;;ttf..........                   ..Li;;11;..,ii;;;;,.1...:
LG0  i;;;11i;t;;;;1;;1t;iLii,....         ,1iL         .:iit:;;1;...i;;;;;;.;...i
CCGi1;;;;ifi;t,;;;;;i;;;ifiiiG..                    .,tCiii::1i1:...i;;;;;;.i....
GGGG1;;;;it;;t.;;;;;i;;,;tiiiii1it;. .          ..:;:::tiii.:11i:...t;;;;;;.i.....
,,,,;;;1;tt;tt.;;;;;;;;.iiiiiiifiiiiiiiit1;...,G:::::::tii1.11ii,...1;i;;;;;;,...i.......
...i;;;;ttf;;1.;;;;i:;..tiiiii11iiiiiiiGCGGGGGGGGGGGGGGG0i1.itii....,;f;;;;;;;...........
..:;;;1;ttf;i;,;;;;i::..1i;iiitiiiiiiifGGGGGGGGGGGGGGGGGLi;1i1ii.....;i;;;;;;i....;.....C
..;;;;;Lffi11,;;;;i1:...G:;f1ii1fL::::G000GGGGGGGGGGG000;;,1iiii.... f;;;;;;;t....;111i;C
,1;;;t1fff;Lt.;;;;Lf,...G:,,,,,,,,,,,,fGGGGGGGGGGGGGG00G::i::::f.....1;1;;;;;;.... 111ttL
:;;;;;0000;Gi.;;;:,:...tG,,,,,,,,,,,,,,GGGGGGGGGGGGG00,,,:1:::::1....1:tft1;;;:....f:::;i
;;;;tt,,,it, .;;1,,,...CG,,,,,,,,,,,,,,L00GGGGGGGGG0,,,,,,:,,,:,1....t;LLLC8L;t....;:::::
;;;i1,,.,t,;.;;L,:, ..,GGt,.........f...GGGGGGGCCC.     .,,    ,:....1CLLG:,  i.....1::::
;;;i.,.,,1,..;1,,,;...t;;................CCCCCCC.  ;..........;;:....tCLG,    .:....t::::
;;f:,,,,,i; .;.,,,t..;G:..............:;i.CCCC i:...............i;...itL.   ;  :....;1:,:
;tt,,,,,t,..;:;:,:1..fG...,;iiii11111t,i1.;Lti:;iii;,...........t:...;i    .    :....iii;
;i,,,,,,1; .1.:1,1,.;GC..,::;iiii1i1iii,,:.t1;itt1i11ii;:......::f;.,;;          ....i1,:
t,,,,,,;,..: ,,,:i.;GCi.........,;;111f1ii11...1i;..,:;;:,....,::LC.,;;          ;...;;,,
,,,,,,,ii .1 ,,,1;;GLf;,..........i11,i000f:i:...............,;.LLC;:;1,    ...  ,....i1,
,,,,,,i, .,  ,,,iiGLL 1::........;i1.i00000i.1;..,;.........:i,LLLtf;;t   ,,,,    ....;;:
::,,:::; ... ,,,;:LLL  ii1ft1111ti;.;f0;10Gt..t:..111t;...;ii,tLL0,:;;1 :i;,i.    1...;i1
11tttff .i , ,;;:1LLL  ft11t,,. ;:..;CG0GtLG..ii...,i1111f11t.LLL:,:;;i:::::    t:;....;.
,,,,:, .,.,, ,fL;iLLL    ..    ::..,;GGGGiLL...1;..i ,11ti,.,CLLL:1 ;it,::     i1CC:...;:
,,,,,,..1.,,.,:111LLL         L:...::GGGG:CL1..1i...  ....   LLL::: i1;:.      :fL1C...:;
,,,:t .; ,,,,,,i::CCC        C;....::GGGG::CC..;;....       CLLLii,:1t,    .....L1i:....;
:,:i .;:.,,,,,,i;1CCC       C1....:.1GGG;  CC;.;,...i       CCC,:i,i11.,,,,,....1f1ti...;
,:: .;t ,,,,,::1;1GCC      Cf.....;,C:LG,..iC1.i....1     .CCCt::f, i;,,,,,,,,;1;:LCC...,
*/



/*
1.Script exec bug?
*/

#include "my.h"
#include <Psapi.h>
#include "KrkrExtract.h"
#include "FakePNG.h"
#include "tp_stub.h"
#include "mt64.h"
#include "MultiThread.h"

#pragma comment(lib, "Psapi.lib")
#pragma comment(lib, "Version.lib")
#pragma comment(lib, "ntdll.lib")
#pragma comment(lib, "MyLibrary_x86_static.lib")

EXTERN_C MY_DLL_EXPORT HRESULT NTAPI V2Link(iTVPFunctionExporter *exporter)
{
	TVPInitImportStub(exporter);
	return S_OK;
}

EXTERN_C MY_DLL_EXPORT HRESULT NTAPI V2Unlink()
{
	return S_OK;
}


ULONG_PTR g_FakeExtractionFilter = NULL;
TVPXP3ArchiveExtractionFilterFunc   g_RealFilter = NULL;
ULONG_PTR                           g_FakeReturnAddress = NULL;

ASM Void WINAPI FakeExtractionFilterAsm(tTVPXP3ExtractionFilterInfo * /* info */)
{
	INLINE_ASM
	{
		mov      ecx, g_RealFilter;
		jecxz    NO_EXT_FILTER;
		mov      eax, g_FakeReturnAddress;
		mov      [esp], eax;
		jmp      ecx;

	NO_EXT_FILTER:
		ret 4;
	}
}

Void WINAPI FakeExtractionFilterWithException(tTVPXP3ExtractionFilterInfo *info)
{
	SEH_TRY
	{
		FakeExtractionFilterAsm(info);
	}
	SEH_EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	}
}

ASM Void WINAPI FakeExtractionFilter(tTVPXP3ExtractionFilterInfo* /* info */)
{
	INLINE_ASM
	{
		push[esp + 4];
		call g_FakeExtractionFilter;
		ret  4;
	}
}

ULONG_PTR FindReturnAddressWorker()
{
	ULONG        State;
	PBYTE        Buffer;
	GlobalData*  Handle;

	enum { FOUND_NONE, FOUND_C2, FOUND_04, FOUND_00 };

	Handle = GlobalData::GetGlobalData();
	Buffer = (PBYTE)GlobalData::GetGlobalData()->FirstSectionAddress;

	State = FOUND_NONE;
	for (ULONG SizeOfImage = Handle->SizeOfImage; SizeOfImage; ++Buffer, --SizeOfImage)
	{
		ULONG b = Buffer[0];

		switch (State)
		{
		case FOUND_NONE:
			if (b == 0xC2)
				State = FOUND_C2;
			break;

		case FOUND_C2:
			switch (b)
			{
			case 0x04:
				State = FOUND_04;
				break;

			case 0xC2:
				State = FOUND_C2;
				break;

			default:
				State = FOUND_NONE;
			}
			break;

		case FOUND_04:
			switch (b)
			{
			case 0x00:
				State = FOUND_00;
				break;

			case 0xC2:
				State = FOUND_C2;
				break;

			default:
				State = FOUND_NONE;
			}
			break;

		case FOUND_00:
			return (ULONG_PTR)Buffer - 3;
		}
	}
	return NULL;
}

ULONG_PTR FindReturnAddress()
{
	__try
	{
		ULONG_PTR ReturnAddress = FindReturnAddressWorker();

		if (ReturnAddress != NULL)
		{
			g_FakeExtractionFilter = (ULONG_PTR)FakeExtractionFilterAsm;
			return ReturnAddress;
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
	}
	return NULL;
}


TVPXP3ArchiveExtractionFilterFunc WINAPI InitFakeFilter(PBOOL Result)
{
	PIMAGE_DOS_HEADER       DosHeader;
	PIMAGE_NT_HEADERS       NtHeader;
	PIMAGE_SECTION_HEADER   SectionHeader;
	GlobalData*             Handle;

	Handle = GlobalData::GetGlobalData();
	g_FakeReturnAddress = FindReturnAddress();
	if (!g_FakeExtractionFilter)
	{
		*Result = FALSE;
		return NULL;
	}

	DosHeader = (PIMAGE_DOS_HEADER)Nt_GetExeModuleHandle();
	NtHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);
	SectionHeader = (PIMAGE_SECTION_HEADER)((ULONG_PTR)NtHeader + NtHeader->FileHeader.SizeOfOptionalHeader + sizeof(*NtHeader) - sizeof(NtHeader->OptionalHeader));

	Handle->FirstSectionAddress = SectionHeader->VirtualAddress + (ULONG_PTR)DosHeader;
	Handle->SizeOfImage = NtHeader->OptionalHeader.SizeOfImage;
	*Result = TRUE;
	return FakeExtractionFilter;
}


API_POINTER(LoadLibraryA) StubLoadLibraryA = NULL;
API_POINTER(LoadLibraryW) StubLoadLibraryW = NULL;

PVOID WINAPI HookLoadLibraryA(LPCSTR lpFileName)
{
	PVOID   Result;
	PWSTR   UnicodeName;
	ULONG   Length, OutLength;
	
	Length      = (StrLengthA(lpFileName) + 1) * 2;
	UnicodeName = (PWSTR)AllocStack(Length);

	RtlZeroMemory(UnicodeName, Length);
	RtlMultiByteToUnicodeN(UnicodeName, Length, &OutLength, lpFileName, Length / 2 - 1);

	Result = StubLoadLibraryW(UnicodeName);

	//some smc will check self, just ingore.
	if (LookupImportTable(Result, "KERNEL32.dll", "FlushInstructionCache") != IMAGE_INVALID_VA)
		return Result;
	
	GlobalData::GetGlobalData()->InitHook(UnicodeName, Result);
	return Result;
}


PVOID WINAPI HookLoadLibraryW(LPCWSTR lpFileName)
{
	PVOID   Result;

	Result = StubLoadLibraryW(lpFileName);

	//some smc will check self, just ingore.
	if (LookupImportTable(Result, "KERNEL32.dll", "FlushInstructionCache") != IMAGE_INVALID_VA)
		return (HMODULE)Result;

	GlobalData::GetGlobalData()->InitHook(lpFileName, Result);

	return Result;
}

XP3Filter pfTVPSetXP3ArchiveExtractionFilter = nullptr;

void WINAPI HookTVPSetXP3ArchiveExtractionFilter(tTVPXP3ArchiveExtractionFilter filter)
{
	BOOL          Result;
	GlobalData*   Handle;

	Handle = GlobalData::GetGlobalData();
	g_RealFilter = filter;

	tTVPXP3ArchiveExtractionFilter FakeFilter = InitFakeFilter(&Result);
	if (Result)
		_InterlockedExchangePointer((PVOID volatile*)&(Handle->pfGlobalXP3Filter), (void*)FakeFilter);
	else
		_InterlockedExchangePointer((PVOID volatile*)&(Handle->pfGlobalXP3Filter), (void*)filter);

	if (Handle->DebugOn)
		PrintConsoleW(L"Filter ProcAddr : %p\n", filter);

	pfTVPSetXP3ArchiveExtractionFilter(filter);
}

typedef iTVPFunctionExporter*   (WINAPI *TVPGetFunctionExporterFunc)();
TVPGetFunctionExporterFunc pfTVPGetFunctionExporter = nullptr;

//多次调用的
iTVPFunctionExporter* WINAPI HookTVPGetFunctionExporter()
{
	iTVPFunctionExporter* Result;
	PVOID                 Target;
	GlobalData*           Handle;

	static char funcname[] = "void ::TVPSetXP3ArchiveExtractionFilter(tTVPXP3ArchiveExtractionFilter)";

	Handle = GlobalData::GetGlobalData();
	Result = pfTVPGetFunctionExporter();
	Handle->TVPFunctionExporter = Result;
	
	if (!Handle->Inited)
	{
		InitExporterByExeModule(Result);
		ImageWorkerV2Link(Result);
		InitLayer();
		Handle->FakePngWorkerInited = TRUE;
		
		pfTVPSetXP3ArchiveExtractionFilter = (XP3Filter)TVPGetImportFuncPtr(funcname);
		
		if (pfTVPSetXP3ArchiveExtractionFilter != nullptr)
		{
			Target = pfTVPSetXP3ArchiveExtractionFilter;
			Mp::PATCH_MEMORY_DATA p[] = 
			{
				Mp::FunctionJumpVa(Target, HookTVPSetXP3ArchiveExtractionFilter, &pfTVPSetXP3ArchiveExtractionFilter)
			};
			
			Mp::PatchMemory(p, countof(p));
		}
		Handle->InitHookNull();
		Handle->Inited = TRUE;
	}
	return Result;
}


FARPROC WINAPI HookGetProcAddress(HMODULE hModule, LPCSTR lpProcName)
{
	if (!StrCompareA(lpProcName, "GetSystemWow64DirectoryA"))
		return NULL;
	
	return GlobalData::GetGlobalData()->StubGetProcAddress(hModule, lpProcName);
}


API_POINTER(CreateFileW) StubCreateFileW = NULL;

HANDLE WINAPI HookCreateFileW(
	LPCWSTR               lpFileName, 
	DWORD                 dwDesiredAccess, 
	DWORD                 dwShareMode,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
	DWORD                 dwCreationDisposition, 
	DWORD                 dwFlagsAndAttributes, 
	HANDLE                hTemplateFile)
{
	wstring     FileName(lpFileName), InternalFileName;
	ULONG_PTR   Index;
	GlobalData* Handle;
	HANDLE      Result;
	MODULEINFO  ModuleInfo;

	Handle = GlobalData::GetGlobalData();

	Index = FileName.find_last_of(L'/');
	if (Index != std::wstring::npos)
		FileName = FileName.substr(Index + 1, std::wstring::npos);

	Index = FileName.find_last_of(L"\\");
	if (Index != std::wstring::npos)
		FileName = FileName.substr(Index + 1, std::wstring::npos);

	RtlZeroMemory(&ModuleInfo, sizeof(MODULEINFO));
	GetModuleInformation(GetCurrentProcess(), GetModuleHandleW(NULL), &ModuleInfo, sizeof(MODULEINFO));
	
	if (IN_RANGE((ULONG_PTR)ModuleInfo.lpBaseOfDll, (ULONG_PTR)_ReturnAddress(), (ULONG_PTR)ModuleInfo.lpBaseOfDll + ModuleInfo.SizeOfImage))
		PrintConsoleW(L"CreateFile : %s\n", lpFileName);

	Result = StubCreateFileW(lpFileName, dwDesiredAccess, dwShareMode,
		lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

	//trace this handle??
	if (!StrICompareW(FileName.c_str(), Handle->CurrentTempFileName.c_str(), StrCmp_ToLower) && Result != INVALID_HANDLE_VALUE && Result != 0)
		InterlockedExchangePointer(&(Handle->CurrentTempHandle), Result);

	return Result;
}


BOOL
WINAPI
HookCreateProcessInternalW(
HANDLE                  hToken,
LPCWSTR                 lpApplicationName,
LPWSTR                  lpCommandLine,
LPSECURITY_ATTRIBUTES   lpProcessAttributes,
LPSECURITY_ATTRIBUTES   lpThreadAttributes,
BOOL                    bInheritHandles,
ULONG                   dwCreationFlags,
LPVOID                  lpEnvironment,
LPCWSTR                 lpCurrentDirectory,
LPSTARTUPINFOW          lpStartupInfo,
LPPROCESS_INFORMATION   lpProcessInformation,
PHANDLE                 phNewToken
)
{
	BOOL             Result, IsSuspended;
	NTSTATUS         Status;
	UNICODE_STRING   FullDllPath;

	RtlInitUnicodeString(&FullDllPath, GlobalData::GetGlobalData()->SelfPath);

	IsSuspended = !!(dwCreationFlags & CREATE_SUSPENDED);
	dwCreationFlags |= CREATE_SUSPENDED;
	Result = GlobalData::GetGlobalData()->StubCreateProcessInternalW(
		hToken,
		lpApplicationName,
		lpCommandLine,
		lpProcessAttributes,
		lpThreadAttributes,
		bInheritHandles,
		dwCreationFlags,
		lpEnvironment,
		lpCurrentDirectory,
		lpStartupInfo,
		lpProcessInformation,
		phNewToken);

	if (!Result)
		return Result;

	Status = InjectDllToRemoteProcess(
		lpProcessInformation->hProcess,
		lpProcessInformation->hThread,
		&FullDllPath,
		IsSuspended
		);

	return TRUE;
}


//InitHookNull()


/*
(stub function)
find the 2nd call:

.text:00445ADE                 call    TJS__TJSAllocStringHeap
.text:00445AE3                 push    [ebp+arg_8]
.text:00445AE6                 mov     esi, eax
.text:00445AE8                 push    ebx
.text:00445AE9                 mov     ecx, esi
.text:00445AEB                 call    TJS__tTJSVariantString__SetString (thiscall)

stub:
static void __stdcall TVP_Stub_c95bd66d95c153cdac41b5243e555f5f(tTJSString * _this, const tjs_char * str , int n)
{
::new (_this) tTJSString(str, n);
}


*/


/*
V5.0:
Hook tString constructor


tTJSCriticalSection StringPushCS;

//TJS::tTJSVariantString::SetString
PVOID StubNewStringWithLength = NULL;

Void NTAPI NewStringWithLength_Internal(PCWSTR String, ULONG Length)
{
	tTJSCriticalSectionHolder Holder(StringPushCS);
	BOOL   FindDot;

	if (Length &&
		String &&
		Length <= MAX_PATH )
		//&& IN_RANGE((ULONG_PTR)Nt_GetExeModuleHandle(), (ULONG_PTR)_ReturnAddress(), 0x200000))
	{
		FindDot = FALSE;
		for (ULONG i = 0; i < Length; i++)
		{
			if (String[i] == L'.')
			{
				FindDot = TRUE;
				break;
			}
		}

		PrintConsoleW(L"%s\n", String);

		if (FindDot)
			GlobalData::GetGlobalData()->FileNameList.push_back(std::wstring(String, Length));
	}
}



ASM Void NewStringWithLength()
{
	INLINE_ASM
	{
		push ebp;
		mov  ebp, esp;

		pushad;
		pushfd;
		push dword ptr [ebp + 0xC];
		push dword ptr [ebp + 0x8];
		call NewStringWithLength_Internal;
		popfd;
		popad;
		
		push dword ptr[ebp + 0xC];
		push dword ptr[ebp + 0x8];
		call StubNewStringWithLength;

		pop ebp;
		retn 8;
	}
}


PVOID KrkrExporter = NULL;
BOOL  InitHookPureAsm_Once = FALSE;
Void NTAPI InitHookPureAsm_Internal(iTVPFunctionExporter* Exportor)
{
	PBYTE       TStringConstructorStub;
	GlobalData* Handle;
	ULONG       iPos, OpSize, CallCount;
	ULONG_PTR   AddressOfCallNewString;

	Handle = GlobalData::GetGlobalData();

	if (InitHookPureAsm_Once == FALSE)
	{
		TVPInitImportStub(Exportor);

		//show the window
		Handle->InitHookNull();

		//try to get file name

		static char TStringConstructor[] = "tTJSString::tTJSString(const tjs_char *,int)";

		LOOP_ONCE
		{
			TStringConstructorStub = (PBYTE)TVPGetImportFuncPtr(TStringConstructor);
			if (!TStringConstructorStub)
				break;

			//Analyze internal proc offset then hook it, build a hash map to holder all string
			iPos      = 0;
			CallCount = 0;
			AddressOfCallNewString = 0;
			while (iPos < 0x200 && TStringConstructorStub[iPos] != 0xCC)
			{
				OpSize = GetOpCodeSize32(&TStringConstructorStub[iPos]);
				if (TStringConstructorStub[iPos] == CALL)
				{
					CallCount++;
					if (CallCount == 2)
					{
						AddressOfCallNewString = GetCallDestination((ULONG_PTR)TStringConstructorStub + iPos);
						break;
					}
				}
				iPos += OpSize;
			}

			if (!AddressOfCallNewString)
				break;

			Mp::PATCH_MEMORY_DATA StringPatch[] = 
			{
				Mp::FunctionJumpVa((PVOID)AddressOfCallNewString, NewStringWithLength, &StubNewStringWithLength)
			};

			Mp::PatchMemory(StringPatch, countof(StringPatch));
		}

		InterlockedExchange((LONG volatile *)&InitHookPureAsm_Once, TRUE);
	}
}

PVOID InitHookPureAsm_End = NULL;
ASM Void InitHookPureAsm()
{
	INLINE_ASM
	{
		mov eax, KrkrExporter;

		pushad;
		pushfd;

		push eax;
		call InitHookPureAsm_Internal

		popfd;
		popad;
		mov eax, KrkrExporter;
	}
}

*/

NTSTATUS WINAPI InitHook()
{
	NtFileDisk            File;
	BOOL                  Success;
	NTSTATUS              Status;
	PVOID                 Kernel32Handle, Target;
	GlobalData*           Handle;
	PVOID                 ExporterPointer;
	ULONG                 Size;
	ULONG64               Crc;
	PIMAGE_DOS_HEADER     DosHeader;
	PIMAGE_NT_HEADERS32   NtHeader;
	PIMAGE_SECTION_HEADER SectionHeader;
	PBYTE                 CurrentSection;
	ULONG_PTR             CurrentSectionSize;
	ULONG_PTR             CurrentCodePtr, CodeSize;

	Handle = GlobalData::GetGlobalData();
	Kernel32Handle = Nt_LoadLibrary(L"KERNEL32.dll");

	Handle->DebugOn = 1;

	PVOID hModule = Nt_GetExeModuleHandle();
	*(FARPROC *)&pfTVPGetFunctionExporter = (FARPROC)Nt_GetProcAddress(hModule, "TVPGetFunctionExporter");

	//Krkr2 & normal Krkrz Module
	if (pfTVPGetFunctionExporter != nullptr)
	{
		Target = pfTVPGetFunctionExporter;
		Mp::PATCH_MEMORY_DATA p[] =
		{
			Mp::FunctionJumpVa( Target, HookTVPGetFunctionExporter, &pfTVPGetFunctionExporter )
		};

		if (Handle->DebugOn)
			PrintConsoleW(L"Normal init...\n");

		Mp::PatchMemory(p, countof(p));
	}
	else
	{
		Success = FALSE;

		/*
		LOOP_ONCE
		{
			Status = File.Open(L"KrkrExtract.db");
			if (NT_FAILED(Status))
				break;

			Size = File.GetSize32();
			if (Size != 8 + sizeof(PVOID))
				break;

			File.Read(&Crc, 8);
			File.Read(&ExporterPointer, sizeof(PVOID));

			ExporterPointer = Nt_DecodePointer(ExporterPointer, LODWORD(Crc));
			if (Crc != GenerationCRC64(0, (LPCBYTE)&ExporterPointer, sizeof(PVOID)))
				break;

			//find "mov     eax, offset TVPFunctionExporter" then hook it
			ExporterPointer = PtrAdd((PBYTE)ExporterPointer, (PBYTE)Nt_GetExeModuleHandle());

			DosHeader = (PIMAGE_DOS_HEADER)Nt_GetExeModuleHandle();
			NtHeader = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);
			SectionHeader = IMAGE_FIRST_SECTION(NtHeader);

			//check here!
			for (ULONG_PTR i = 0; i < NtHeader->FileHeader.NumberOfSections; i++, SectionHeader++)
			{
				CurrentSection = SectionHeader->VirtualAddress + (PBYTE)DosHeader;
				CurrentSectionSize = SectionHeader->Misc.VirtualSize;
				CurrentCodePtr = 0;

				if (SectionHeader->Characteristics & IMAGE_SCN_CNT_CODE)
				{
					while (CurrentCodePtr < CurrentSectionSize)
					{
						//mov eax, mem.offset
						if (CurrentSection[CurrentCodePtr] == 0xB8 &&
							GetOpCodeSize32(&CurrentSection[CurrentCodePtr]) == 5)
						{
							if (*(PDWORD)&CurrentSection[CurrentCodePtr + 1] == (DWORD)ExporterPointer)
							{
								//we have more five bytes executable buffer, 
								//hook it, and receive the notification when the exporter have already been initialized

								Mp::PATCH_MEMORY_DATA p[] =
								{
									Mp::FunctionJumpVa(CurrentCodePtr + CurrentSection, InitHookPureAsm, NULL)
								};
								KrkrExporter = ExporterPointer;
								InitHookPureAsm_End = CurrentCodePtr + CurrentSection + 5;

								Mp::PatchMemory(p, countof(p));

								Success = TRUE;
								Status = STATUS_SUCCESS;
								break;
							}
							CurrentCodePtr += 5;
						}
						else
						{
							CodeSize = GetOpCodeSize32(&CurrentSection[CurrentCodePtr]);
							CurrentCodePtr += CodeSize;
						}
					}
				}
			}//end of LOOP_ONCE
		}
		File.Close();
		*/

		if (!Success)
		{
			//Nt_DeleteFile(L"KrkrExtract.db");

			Mp::PATCH_MEMORY_DATA f[] =
			{
				Mp::FunctionJumpVa(LoadLibraryA, HookLoadLibraryA, &StubLoadLibraryA),
				Mp::FunctionJumpVa(LoadLibraryW, HookLoadLibraryW, &StubLoadLibraryW)
			};

			if (Handle->DebugOn)
				PrintConsoleW(L"Special init...\n");

			Mp::PatchMemory(f, countof(f));
		}

		Mp::PATCH_MEMORY_DATA CommonPatch[] =
		{
			Mp::FunctionJumpVa(CreateFileW, HookCreateFileW, &StubCreateFileW)
		};

		Mp::PatchMemory(CommonPatch, countof(CommonPatch));
	}

	*(PVOID*)&Handle->StubCreateProcessInternalW = Nt_GetProcAddress(Kernel32Handle, "CreateProcessInternalW");
	Target = Handle->StubCreateProcessInternalW;

	Mp::PATCH_MEMORY_DATA f[] =
	{
		Mp::FunctionJumpVa(Target, HookCreateProcessInternalW, &Handle->StubCreateProcessInternalW)
	};

	Mp::PatchMemory(f, countof(f));

	//module path check
	if (Nt_CurrentPeb()->OSMajorVersion > 6 || (Nt_CurrentPeb()->OSMajorVersion == 6 && Nt_CurrentPeb()->OSMinorVersion >= 2))
	{
		Mp::PATCH_MEMORY_DATA ooxx[] =
		{
			Mp::FunctionJumpVa(GetProcAddress, HookGetProcAddress, &Handle->StubGetProcAddress)
		};

		Mp::PatchMemory(ooxx, countof(ooxx));
	}

	return STATUS_SUCCESS;
}


API_POINTER(MultiByteToWideChar) StubMultiByteToWideChar = NULL;
INT NTAPI HookMultiByteToWideChar(
	UINT   CodePage,
	DWORD  dwFlags,
	LPCSTR lpMultiByteStr,
	int    cbMultiByte,
	LPWSTR lpWideCharStr,
	int    cchWideChar
)
{
	switch (CodePage)
	{
	case CP_ACP:
	case CP_OEMCP:
	case CP_THREAD_ACP:
		CodePage = 932;
		break;

	default:
		break;
	}

	return
		StubMultiByteToWideChar(
		CodePage,
		dwFlags,
		lpMultiByteStr,
		cbMultiByte,
		lpWideCharStr,
		cchWideChar
		);
}


Void FASTCALL EnumerateFileInDirectory(LPCWSTR szPath, std::vector<std::wstring>& FileList)
{
	WIN32_FIND_DATAW FindFileData;
	HANDLE           hListFile;
	WCHAR            FilePath[MAX_PATH];
	NtFileDisk       File;
	NTSTATUS         Status;

	FormatStringW(FilePath, L"%s\\*.*", szPath);
	hListFile = Nt_FindFirstFile(FilePath, &FindFileData);

	auto IsXp3File = [](HANDLE hFile)->BOOL
	{
		BOOL          Success;
		LARGE_INTEGER OldOffset, NewOffset, Size;
		BYTE          Mark[0x1000];
		BYTE          Buffer[0x10000], *Xp3Signature;
		DWORD         BytesRead;

		static BYTE   XP3Header[] = { 0x58, 0x50, 0x33, 0x0D, 0x0A, 0x20, 0x0A, 0x1A, 0x8B, 0x67, 0x01 };

		if (hFile == 0 || hFile == INVALID_HANDLE_VALUE)
			return FALSE;

		OldOffset.QuadPart = 0;
		NewOffset.QuadPart = 0;
		SetFilePointerEx(hFile, NewOffset, &OldOffset, FILE_CURRENT);
		GetFileSizeEx(hFile, &Size);
		NewOffset.QuadPart = 0;
		Success = FALSE;
		SetFilePointerEx(hFile, NewOffset, NULL, FILE_BEGIN);
		if (Size.QuadPart > sizeof(StaticXP3V2Magic))
		{
			if (Size.QuadPart >= 0x1000)
			{
				ReadFile(hFile, Mark, sizeof(Mark), NULL, NULL);
				if (RtlCompareMemory(Mark, StaticXP3V2Magic, sizeof(StaticXP3V2Magic)) == sizeof(StaticXP3V2Magic))
				{
					Success = TRUE;
				}
				else
				{
					LOOP_ONCE
					{
						if (((PIMAGE_DOS_HEADER)Mark)->e_magic != IMAGE_DOS_SIGNATURE)
						break;

						SetFilePointer(hFile, 0x10, NULL, FILE_BEGIN);
						for (LONG64 FileSize = Size.QuadPart; FileSize > 0; FileSize -= sizeof(Buffer))
						{
							ReadFile(hFile, Buffer, sizeof(Buffer), &BytesRead, NULL);

							if (BytesRead < 0x10)
								break;

							Xp3Signature = Buffer;
							for (ULONG_PTR Count = sizeof(Buffer) / 0x10; Count; Xp3Signature += 0x10, --Count)
							{
								if (RtlCompareMemory(Xp3Signature, XP3Header, sizeof(XP3Header)) == sizeof(XP3Header))
								{
									Success = TRUE;
									break;
								}
							}
						}
					}
				}
			}
			else
			{
				ReadFile(hFile, Mark, sizeof(StaticXP3V2Magic), NULL, NULL);
				if (RtlCompareMemory(Mark, StaticXP3V2Magic, sizeof(StaticXP3V2Magic)) == sizeof(StaticXP3V2Magic))
					Success = TRUE;
			}
		}
		SetFilePointerEx(hFile, OldOffset, NULL, FILE_BEGIN);
		return Success;
	};


	if (hListFile != INVALID_HANDLE_VALUE)
	{
		do
		{
			if(StrCompareW(FindFileData.cFileName, L".") == 0 ||
			   StrCompareW(FindFileData.cFileName, L"..") == 0)
			{
				continue;
			}

			if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				FormatStringW(FilePath, L"%s\\%s", szPath, FindFileData.cFileName);
				EnumerateFileInDirectory(FilePath, FileList);
			}
			else
			{
				FormatStringW(FilePath, L"%s\\%s", szPath, FindFileData.cFileName);
				Status = File.Open(FilePath);
				if(NT_SUCCESS(Status) && IsXp3File(File.GetHandle()))
					FileList.push_back(FilePath);

				File.Close();
			}

		} while (Nt_FindNextFile(hListFile, &FindFileData));
	}
}



//TVP(KIRIKIRI) Z core / Scripting Platform for Win32
//TVP(KIRIKIRI) 2 core / Scripting Platform for Win32

BOOL NTAPI InitKrkrExtract(HMODULE hModule)
{
	BOOL            Success;
	GlobalData*     Handle;
	vector<wstring> FileList;
	WCHAR           ExeDirectory[MAX_PATH];
	wstring         CurFileName;
	ULONG_PTR       Index, Index2;

	static WCHAR Pattern[] = L"TVP(KIRIKIRI) Z core / Scripting Platform for Win32";

	//or search entrypoint???
	auto CheckKrkrZ = [&]()->NTSTATUS
	{
		NTSTATUS   Status;
		NtFileDisk File;
		ULONG_PTR  FileSize;
		PBYTE      FileBuffer;
		WCHAR      FileName[MAX_PATH];

		Handle = GlobalData::GetGlobalData();

		RtlZeroMemory(FileName,   countof(FileName) * sizeof(FileName[0]));
		Nt_GetModuleFileName(Nt_GetExeModuleHandle(), FileName,  MAX_PATH * 2);

		LOOP_ONCE
		{
			Status = File.Open(FileName);
			if (NT_FAILED(Status))
				break;

			Status     = STATUS_INSUFFICIENT_RESOURCES;
			FileSize   = File.GetSize32();
			FileBuffer = (PBYTE)AllocateMemoryP(FileSize);
			
			if (!FileBuffer)
				break;

			File.Read(FileBuffer, FileSize);
			if (Handle->FindCodeSlow((PCChar)FileBuffer, FileSize, (PCHAR)Pattern, StrLengthW(Pattern) * 2))
			{
				//ensure the codepage
				Mp::PATCH_MEMORY_DATA f[] = 
				{
					Mp::FunctionJumpVa(MultiByteToWideChar, HookMultiByteToWideChar, &StubMultiByteToWideChar )
				};

				Mp::PatchMemory(f, countof(f));
				Handle->ModuleType = ModuleVersion::Krkrz;
			}
			FreeMemoryP(FileBuffer);
		}
		File.Close();
		return Status;
	};

	LOOP_ONCE
	{
		Success = FALSE;
		Handle  = GlobalData::GetGlobalData();
		if (!Handle)
			break;

		//Handle->DebugOn = TRUE;
		Io::DeleteFileW(L"KrkrExtractFailed.txt");
		
		Handle->SetDllModule(hModule);
		
		//insert all xp3 files, including exe
		RtlZeroMemory(ExeDirectory, sizeof(ExeDirectory));
		Nt_GetExeDirectory(ExeDirectory, countof(ExeDirectory));

		/*
		EnumerateFileInDirectory(ExeDirectory, FileList);

		for (auto& StringItem : FileList)
		{
			for (auto& ItemChar : StringItem)
				ItemChar = CHAR_LOWER(ItemChar);

			Index = StringItem.find_last_of(L'\\');
			Index2 = StringItem.find_last_of(L'/');

			if (Index == wstring::npos && Index2 == wstring::npos)
				CurFileName = StringItem;
			else if (Index == wstring::npos && Index2 != wstring::npos)
				CurFileName = StringItem.substr(Index2 + 1, wstring::npos);
			else if (Index != wstring::npos && Index2 == wstring::npos)
				CurFileName = StringItem.substr(Index + 1, wstring::npos);
			else
				CurFileName = StringItem.substr(max(Index, Index2) + 1, wstring::npos);


			PrintConsoleW(L"found %s\n", CurFileName.c_str());

			Xp3FileEntry Entry;
			Handle->FileInitList.insert(std::make_pair(CurFileName, Entry));
		}
		*/

		Success = NT_FAILED(CheckKrkrZ()) ? FALSE : TRUE;
		Success = NT_FAILED(InitHook())   ? FALSE : TRUE;
	}

	return Success;
}

ULONG64 MurmurHash64B(const void * key, int len, ULONG seed = 0xEE6B27EB)
{
	const unsigned int m = 0x5bd1e995;
	const int r = 24;

	unsigned int h1 = seed ^ len;
	unsigned int h2 = 0;

	const unsigned int * data = (const unsigned int *)key;

	while (len >= 8)
	{
		unsigned int k1 = *data++;
		k1 *= m; k1 ^= k1 >> r; k1 *= m;
		h1 *= m; h1 ^= k1;
		len -= 4;

		unsigned int k2 = *data++;
		k2 *= m; k2 ^= k2 >> r; k2 *= m;
		h2 *= m; h2 ^= k2;
		len -= 4;
	}

	if (len >= 4)
	{
		unsigned int k1 = *data++;
		k1 *= m; k1 ^= k1 >> r; k1 *= m;
		h1 *= m; h1 ^= k1;
		len -= 4;
	}

	switch (len)
	{
	case 3: h2 ^= ((unsigned char*)data)[2] << 16;
	case 2: h2 ^= ((unsigned char*)data)[1] << 8;
	case 1: h2 ^= ((unsigned char*)data)[0];
		h2 *= m;
	};

	h1 ^= h2 >> 18; h1 *= m;
	h2 ^= h1 >> 22; h2 *= m;
	h1 ^= h2 >> 17; h1 *= m;
	h2 ^= h1 >> 19; h2 *= m;

	unsigned long long h = h1;

	h = (h << 32) | h2;

	return h;
}

Void InitRand(HMODULE hModule)
{
	ULONG64  Seeds[4];
	WCHAR    Path[MAX_PATH];

	RtlZeroMemory(Path, countof(Path) * 2);
	Nt_GetExeDirectory(Path, MAX_PATH);
	
	Seeds[0] = MakeQword(Nt_GetCurrentProcessId(),     Nt_GetCurrentThreadId());
	Seeds[1] = MakeQword(Nt_CurrentPeb()->ProcessHeap, Nt_CurrentTeb()->EnvironmentPointer);
	Seeds[2] = MurmurHash64B(Path, StrLengthW(Path) * 2);
	Seeds[3] = MakeQword(hModule, Nt_GetExeModuleHandle());

	init_by_array64(Seeds, countof(Seeds));
}

OVERLOAD_CPP_METHOD_NEW_WITH_HEAP(Nt_CurrentPeb()->ProcessHeap);

BOOL NTAPI DllMain(HMODULE hModule, DWORD Reason, LPVOID lpReserved)
{
	UNREFERENCED_PARAMETER(lpReserved);

	switch (Reason)
	{
	case DLL_PROCESS_ATTACH:
		//AllocConsole();
		ml::MlInitialize();
		LdrDisableThreadCalloutsForDll(hModule);
		InitRand(hModule);
		GlobalData::GetGlobalData();

		if (!InitKrkrExtract(hModule))
		{
			ExceptionBox(L"Internal exception!");
			Ps::ExitProcess(-1);
		}

	break;

	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}

